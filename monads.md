```

Класс Monad присутствует в стандартном модуле Prelude. Для реализации данного класса требуется любой однопараметрический тип (тип рода * -> *). Монада обладает четырьмя методами

class Functor f where
  fmap   :: (a -> b) -> f a -> f b

class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
  (*>) :: f a -> f b -> f b
  (<*) :: f a -> f b -> f a

-- m :: * -> *
class Applicative m => Monad m where
  (>>=)  :: m a -> (a -> m b) -> m b
  (>>)   :: m a -> m b -> m b -- реализован по-умолчанию: a >> b = a >>= \_ -> b
  return :: a -> m a -- = pure
  fail   :: String -> m a -- по-умолчанию вызывает errorWithoutStackTrace
Метод return может ввести в заблуждение программистов, знакомых с императивными языками: он не прерывает вычисления, а лишь упаковывает произвольное значение типа a в монаду m. Метод fail не имеет отношения к теоретической сущности монад, однако используется в случае ошибки сопоставления с образцом внутри монадического вычисления.[2]). Оператор >>= является функцией связывания. Оператор >> — частный случай оператора >>=, используется когда нам не важен результат связывания.

Некоторые типы, реализующие класс Monad:

IO, используется для функций с побочным эффектом. Конструкторы IO скрыты от программиста, также отсутствуют функции распаковки монады. Это не позволяет вызывать грязные функции из чистых.
Maybe. Вычисление прерывается, если получено значение Nothing.
[] (список). Вычисление прерывается при пустом списке. При непустом списке оператор >>= вызывает функцию для каждого элемента списка.
Reader.
Writer.
State. Помимо возможностей Reader позволяет изменять состояние.
В языке также присутствует do-нотация, которая является более удобной формой записи монадических функций. В данном примере f1 использует do-нотацию, а f2 записана с помощью операторов связывания:

f1 = do
  s <- getLine
  putStrLn $ "Hello " ++ s
  putStrLn "sdfsdfs"

f2 = getLine >>=
  (\s -> putStrLn $ "Hello " ++ s) >>
  putStrLn "sdfsfsdf"
```
